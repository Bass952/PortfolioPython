# -*- coding: utf-8 -*-
"""Value at Risk: Historical, Parametric and Monte Carlo Methods.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/115-D4C1JGkxd5_Gzhwrfib-N0mN4Ehmh
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math as m
from scipy.stats import norm

# We should have imported a time series, but we generate it using Geometric Brownian Motion (GBM)
# In practice, we initialize the price, the daily return mean (mu), 0.5%, a daily volatility of 2%, and simulate 500 days.

# Parameters
S0 = 100  # Initial stock index value
mu = 0.0005  # Daily expected return (around 12% annualized)
sigma = 0.02  # Daily volatility (around 20% annualized)
days = 500  # Number of days to simulate
dt = 1  # Time step (1 day)

# Generate random noise for returns using a standard normal distribution
np.random.seed(42)  # For reproducibility
Z = np.random.normal(0, 1, days)  # Random shocks derived from Brownian motion (Wiener process)

# Generate stock prices using Geometric Brownian Motion (GBM)
price = [S0]  # Start with the initial price
for i in range(1, days):
    S_prev = price[-1]  # Previous day's price
    St = S_prev * m.exp(mu * dt + sigma * np.sqrt(dt) * Z[i])  # GBM formula
    price.append(St)  # Append the new price to the list

# Create a time series DataFrame
time_series = pd.DataFrame({
    'Day': range(1, days + 1),  # Days from 1 to 500
    'Price': price  # Simulated stock prices
})

# Plot the time series
plt.figure(figsize=(10, 5))
plt.plot(time_series['Day'], time_series['Price'], label='Stock Index')
plt.title('Stock Index Time Series (500 Days)')
plt.xlabel('Days')
plt.ylabel('Price')
plt.grid()
plt.legend()
plt.show()

# Calculate the 1-day Value at Risk (VaR) at 99% confidence level using historical returns
VaR99_1d = time_series['Price'].pct_change().sort_values().iloc[int(0.01 * days) - 1]

# Calculate Expected Shortfall (ES) as the average of the worst 1% of returns
ES = time_series['Price'].pct_change().sort_values().iloc[0:int(0.01 * days)].mean()  # E[X | X <= VaR]

# Portfolio value
Pfolio_Value = 500000000  # Portfolio value in EUR

# Print the 1-day VaR and 10-day VaR at 99% confidence level
print(f'The Portfolio Daily VaR at 99% is {round(VaR99_1d * 100, 1)}%; in EUR is {round(VaR99_1d * Pfolio_Value, 1)}')
print(f'The 10-day VaR at 99% is {round(VaR99_1d * 100 * np.sqrt(10), 1)}%; in EUR is {round(VaR99_1d * Pfolio_Value * np.sqrt(10), 1)}')

# Calculate the parametric VaR at 99% confidence level
VaR99_1d_par = mu - sigma * norm.ppf(0.99)

# Monte Carlo simulation for VaR
np.random.seed(40)  # For reproducibility
Z1 = np.random.normal(0, 1, days)  # Random shocks for Monte Carlo simulation
ret_MC = []  # List to store Monte Carlo returns

# Generate stock prices using Monte Carlo simulation
for i in range(1, days):
    St_MC = S0 * m.exp(mu * dt + sigma * np.sqrt(dt) * Z1[i])  # GBM formula for Monte Carlo
    ret_MC.append(m.log(St_MC / S0))  # Log returns

# Sort the Monte Carlo returns and calculate the 1-day VaR at 99% confidence level
ret_MC = np.sort(np.array(ret_MC))
VaR99_1d_MC = ret_MC[int(0.01 * days) - 1]

# Plot the distribution of returns
x = np.linspace(mu - 3 * sigma, mu + 3 * sigma, len(time_series['Price']))  # Range for normal distribution
pdf = norm.pdf(x, mu, sigma)  # Probability density function of the normal distribution

plt.figure(figsize=(10, 5))
plt.hist(time_series['Price'].pct_change().sort_values(), bins=20, density=True, alpha=0.6, color='b', label='Historical Returns Histogram')
plt.plot(x, pdf, 'r', label='Normal PDF')  # Plot the normal distribution
plt.axvline(VaR99_1d, color='black', linestyle='--', label=f'VaR 99% Hist = {VaR99_1d * 100:.2f}%')  # Historical VaR
plt.axvline(VaR99_1d_par, color='green', linestyle='--', label=f'VaR 99% Par = {VaR99_1d_par * 100:.2f}%')  # Parametric VaR
plt.axvline(VaR99_1d_MC, color='orange', linestyle='--', label=f'VaR 99% MC = {VaR99_1d_MC * 100:.2f}%')  # Monte Carlo VaR
plt.title('Distribution of Returns')
plt.xlabel('Returns')
plt.ylabel('Frequency')
plt.legend()
plt.grid()
plt.show()